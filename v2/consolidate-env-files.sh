#!/bin/bash

# This script consolidates individual service .env files into a single main .env file

# Define help function
show_help() {
    echo "Usage: $0 [OPTIONS]"
    echo
    echo "Options:"
    echo "  -h, --help              Display this help message"
    echo "  -o, --output <path>     Specify output file path (default: ./.env)"
    echo "  -f, --force             Overwrite existing output file without prompting"
    echo "  -c, --config <path>     Specify services configuration file path (YAML)"
    echo "  -d, --discover          Auto-discover services by scanning directories"
    echo
    echo "This script consolidates individual service .env files into a single main .env file."
}

# Check if yq is installed
check_dependencies() {
    if ! command -v yq &> /dev/null; then
        echo "Error: This script requires yq to parse YAML files."
        echo "Please install yq using one of the following methods:"
        echo "  - Homebrew (macOS): brew install yq"
        echo "  - Apt (Debian/Ubuntu): apt-get install yq"
        echo "  - Snap: snap install yq"
        echo "  - Go: go install github.com/mikefarah/yq/v4@latest"
        echo "  - Download binary from: https://github.com/mikefarah/yq/releases"
        exit 1
    fi
}

# Process command line arguments
OUTPUT_FILE=""
FORCE_OVERWRITE=false
CONFIG_FILE=""
AUTO_DISCOVER=false
while [[ $# -gt 0 ]]; do
    case "$1" in
        -h|--help)
            show_help
            exit 0
            ;;
        -o|--output)
            if [[ -n "$2" && "$2" != -* ]]; then
                OUTPUT_FILE="$2"
                shift 2
            else
                echo "Error: Argument for $1 is missing" >&2
                show_help
                exit 1
            fi
            ;;
        -f|--force)
            FORCE_OVERWRITE=true
            shift
            ;;
        -c|--config)
            if [[ -n "$2" && "$2" != -* ]]; then
                CONFIG_FILE="$2"
                shift 2
            else
                echo "Error: Argument for $1 is missing" >&2
                show_help
                exit 1
            fi
            ;;
        -d|--discover)
            AUTO_DISCOVER=true
            shift
            ;;
        *)
            echo "Unknown option: $1" >&2
            show_help
            exit 1
            ;;
    esac
done

# Check for dependencies
check_dependencies

# Get script directory in a platform-independent way
SCRIPT_DIR=$(cd "$(dirname "$0")" && pwd)
INFRA_DIR="$SCRIPT_DIR"
PROJECT_ROOT=$(dirname "$INFRA_DIR")

# Add debugging
echo "Script location: $0"
echo "Script directory: $SCRIPT_DIR"
echo "Infrastructure directory: $INFRA_DIR"
echo "Project root: $PROJECT_ROOT"
echo "Working directory: $(pwd)"

# Set output file path
if [[ -n "$OUTPUT_FILE" ]]; then
    CONSOLIDATED_ENV_FILE="$OUTPUT_FILE"
else
    CONSOLIDATED_ENV_FILE="$INFRA_DIR/.env"
fi

# Set default config file path if not specified
if [[ -z "$CONFIG_FILE" ]]; then
    CONFIG_FILE="$INFRA_DIR/services-config.yaml"
fi

# Check if output file exists
if [ -f "$CONSOLIDATED_ENV_FILE" ] && [ "$FORCE_OVERWRITE" = false ]; then
    read -p "Output file $CONSOLIDATED_ENV_FILE already exists. Overwrite? (y/n) " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo "Operation cancelled."
        exit 0
    fi
fi

# Initialize consolidated file with header
echo "# Consolidated .env file" > "$CONSOLIDATED_ENV_FILE"
echo "# Generated on: $(date)" >> "$CONSOLIDATED_ENV_FILE"
echo "# This file was automatically generated by consolidating service-specific .env files" >> "$CONSOLIDATED_ENV_FILE"
echo "# DO NOT EDIT THIS FILE DIRECTLY - Edit individual service .env files instead" >> "$CONSOLIDATED_ENV_FILE"
echo "" >> "$CONSOLIDATED_ENV_FILE"

# Initialize arrays to store services information
declare -a COMMON_SERVICES
declare -a APP_SERVICES

# Track variables to avoid duplicates
PROCESSED_VARS=""

# Load configuration from YAML file if specified and it exists
if [ -f "$CONFIG_FILE" ]; then
    echo "Loading services configuration from $CONFIG_FILE"

    # Load common infrastructure services first
    if [ "$AUTO_DISCOVER" = false ]; then
        # Check if common_services section exists
        if yq eval '.common_services' "$CONFIG_FILE" | grep -q -v "null"; then
            echo "Processing common infrastructure services first..."
            common_count=$(yq eval '.common_services | length' "$CONFIG_FILE")

            for ((i=0; i<$common_count; i++)); do
                service_name=$(yq eval ".common_services[$i].name" "$CONFIG_FILE")
                env_file=$(yq eval ".common_services[$i].env_file" "$CONFIG_FILE")
                prefix=$(yq eval ".common_services[$i].prefix" "$CONFIG_FILE")

                # Convert relative paths if needed
                if [[ "$env_file" == ../* ]]; then
                    # Path is relative to the script location
                    env_file="$PROJECT_ROOT/${env_file#../}"
                elif [[ "$env_file" == ./* ]]; then
                    # Path is relative to the infrastructure directory
                    env_file="$INFRA_DIR/${env_file#./}"
                elif [[ "$env_file" != /* ]]; then
                    # If not absolute and no leading ./ or ../
                    # First try the project root
                    if [ -f "$PROJECT_ROOT/$env_file" ]; then
                        env_file="$PROJECT_ROOT/$env_file"
                    # Then try within the infra directory itself
                    elif [ -f "$INFRA_DIR/$env_file" ]; then
                        env_file="$INFRA_DIR/$env_file"
                    fi
                fi

                COMMON_SERVICES+=("$service_name:$prefix:$env_file")
            done
        fi

        # Load application services
        service_count=$(yq eval '.services | length' "$CONFIG_FILE")

        for ((i=0; i<$service_count; i++)); do
            service_name=$(yq eval ".services[$i].name" "$CONFIG_FILE")
            env_file=$(yq eval ".services[$i].env_file" "$CONFIG_FILE")
            # Get prefix directly from service entry
            prefix=$(yq eval ".services[$i].prefix" "$CONFIG_FILE")

            # Convert relative paths if needed
            if [[ "$env_file" == ../* ]]; then
                # Path is relative to the script location
                env_file="$PROJECT_ROOT/${env_file#../}"
            elif [[ "$env_file" == ./* ]]; then
                # Path is relative to the infrastructure directory
                env_file="$INFRA_DIR/${env_file#./}"
            elif [[ "$env_file" != /* ]]; then
                # If not absolute and no leading ./ or ../
                # First try the project root
                if [ -f "$PROJECT_ROOT/$env_file" ]; then
                    env_file="$PROJECT_ROOT/$env_file"
                # Then try within the infra directory itself
                elif [ -f "$INFRA_DIR/$env_file" ]; then
                    env_file="$INFRA_DIR/$env_file"
                fi
            fi

            APP_SERVICES+=("$service_name:$prefix:$env_file")
        done
    fi
else
    if [ "$AUTO_DISCOVER" = false ]; then
        echo "Warning: Config file $CONFIG_FILE not found and auto-discovery is disabled."
        echo "No services will be processed. Use -d or provide a valid config file."
        exit 1
    fi
fi

# Auto-discover services if enabled
if [ "$AUTO_DISCOVER" = true ]; then
    echo "Auto-discovering services..."

    # Find directories with .env files
    for dir in "$PROJECT_ROOT"/*; do
        if [ -d "$dir" ]; then
            service_name=$(basename "$dir")
            env_file="$dir/.env"

            if [ -f "$env_file" ]; then
                # Try to get prefix from YAML configuration
                prefix=""
                if [ -f "$CONFIG_FILE" ]; then
                    # Look for the service in common services first
                    for ((i=0; i<$(yq eval '.common_services | length' "$CONFIG_FILE"); i++)); do
                        if [ "$(yq eval ".common_services[$i].name" "$CONFIG_FILE")" = "$service_name" ]; then
                            prefix=$(yq eval ".common_services[$i].prefix" "$CONFIG_FILE")
                            break
                        fi
                    done

                    # If not found in common, look in services
                    if [ -z "$prefix" ]; then
                        for ((i=0; i<$(yq eval '.services | length' "$CONFIG_FILE"); i++)); do
                            if [ "$(yq eval ".services[$i].name" "$CONFIG_FILE")" = "$service_name" ]; then
                                prefix=$(yq eval ".services[$i].prefix" "$CONFIG_FILE")
                                break
                            fi
                        done
                    fi
                fi

                # Use default prefix naming convention if not found in config
                if [ -z "$prefix" ]; then
                    # Convert to uppercase and replace hyphens with underscores
                    prefix=$(echo "$service_name" | tr '[:lower:]' '[:upper:]' | tr '-' '_')
                    prefix="${prefix}_"
                    echo "Using auto-generated prefix $prefix for $service_name"
                fi

                # Check if this is a common service
                if [ -f "$CONFIG_FILE" ] && yq eval ".common_services[].name | select(. == \"$service_name\")" "$CONFIG_FILE" | grep -q "$service_name"; then
                    COMMON_SERVICES+=("$service_name:$prefix:$env_file")
                else
                    APP_SERVICES+=("$service_name:$prefix:$env_file")
                fi
            fi
        fi
    done

    echo "Discovered $((${#COMMON_SERVICES[@]} + ${#APP_SERVICES[@]})) services (${#COMMON_SERVICES[@]} common, ${#APP_SERVICES[@]} application)"
fi

# Function to consolidate .env files
consolidate_env_file() {
    local service_name=$1
    local prefix=$2
    local env_file=$3
    local is_common=$4

    # Check if env file exists
    if [ ! -f "$env_file" ]; then
        echo "Warning: .env file for $service_name not found at $env_file"
        return 0
    fi

    # Add section header for service
    echo "# $service_name environment variables" >> "$CONSOLIDATED_ENV_FILE"

    # Process each line in the env file
    local var_count=0
    while IFS= read -r line || [[ -n "$line" ]]; do
        # Skip comments and empty lines
        if [[ "$line" =~ ^#.*$ ]] || [[ -z "$line" ]]; then
            continue
        fi

        # Extract variable name
        var_name=$(echo "$line" | cut -d= -f1)

        # Check if already has prefix
        if [[ "$var_name" == "$prefix"* ]]; then
            # Variable already has correct prefix
            prefixed_var="$var_name"
        else
            # Add prefix to variable
            prefixed_var="${prefix}${var_name}"
            line="${prefix}${line}"
        fi

        # Check for duplicates using string search
        if ! echo "$PROCESSED_VARS" | grep -q ":$prefixed_var:"; then
            # New variable, add to consolidated file
            echo "$line" >> "$CONSOLIDATED_ENV_FILE"
            PROCESSED_VARS="$PROCESSED_VARS:$prefixed_var:"
            var_count=$((var_count + 1))
        else
            # For common services, we never show warnings because they're expected to be reused
            # For application services, we show warnings when they use variables from common services
            if [ "$is_common" != "true" ]; then
                echo "Note: Variable $prefixed_var is already defined in a common service"
            fi
        fi
    done < "$env_file"

    echo "" >> "$CONSOLIDATED_ENV_FILE"
    if [ "$is_common" = "true" ]; then
        echo "Processed common service $env_file - added $var_count variables"
    else
        echo "Processed $env_file - added $var_count variables"
    fi
    return $var_count
}

# Process common services first
common_success_count=0
common_total_vars=0

echo "" >> "$CONSOLIDATED_ENV_FILE"
echo "# === COMMON INFRASTRUCTURE VARIABLES ===" >> "$CONSOLIDATED_ENV_FILE"
echo "" >> "$CONSOLIDATED_ENV_FILE"

for service in "${COMMON_SERVICES[@]}"; do
    IFS=':' read -r service_name prefix env_file <<< "$service"

    consolidate_env_file "$service_name" "$prefix" "$env_file" "true"
    local_var_count=$?
    if [ $local_var_count -gt 0 ]; then
        common_success_count=$((common_success_count + 1))
        common_total_vars=$((common_total_vars + local_var_count))
    fi
done

# Process application services
app_success_count=0
app_total_vars=0

echo "" >> "$CONSOLIDATED_ENV_FILE"
echo "# === APPLICATION-SPECIFIC VARIABLES ===" >> "$CONSOLIDATED_ENV_FILE"
echo "" >> "$CONSOLIDATED_ENV_FILE"

for service in "${APP_SERVICES[@]}"; do
    IFS=':' read -r service_name prefix env_file <<< "$service"

    consolidate_env_file "$service_name" "$prefix" "$env_file" "false"
    local_var_count=$?
    if [ $local_var_count -gt 0 ]; then
        app_success_count=$((app_success_count + 1))
        app_total_vars=$((app_total_vars + local_var_count))
    fi
done

echo "Environment file consolidation completed."
echo "$common_success_count common infrastructure .env files processed with $common_total_vars variables."
echo "$app_success_count application-specific .env files processed with $app_total_vars variables."
echo "Consolidated $((common_total_vars + app_total_vars)) unique environment variables."
echo "Consolidated .env file created at $CONSOLIDATED_ENV_FILE"